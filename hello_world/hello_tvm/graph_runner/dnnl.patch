dnnl byoc implementation sucks:

1. `multiply` and `subtract` is not supported in dnnl_json_runtime, but are registered in dnnl.py
2. `add` in dnnl_json_runtime doesn't support broadcast
3. `nn.relu` in dnnl_json_runtime will assume `relu` input is always a 4-dim tensor
4. `conv2d` in dnnl_json_runtime is WRONG, see the attached patch for details

modified   python/tvm/relay/op/contrib/dnnl.py
@@ -62,10 +62,10 @@ def _register_external_op_helper(op_name, supported=True):
 _register_external_op_helper("nn.batch_norm")
 _register_external_op_helper("nn.conv2d")
 _register_external_op_helper("nn.dense")
-_register_external_op_helper("nn.relu")
-_register_external_op_helper("add")
-_register_external_op_helper("subtract")
-_register_external_op_helper("multiply")
+# _register_external_op_helper("nn.relu")
+# _register_external_op_helper("add")
+# _register_external_op_helper("subtract")
+# _register_external_op_helper("multiply")
 
 
 def make_pattern(with_bias=True):
modified   src/runtime/contrib/dnnl/dnnl_json_runtime.cc
@@ -163,14 +163,14 @@ class DNNLJSONRuntime : public JSONRuntimeBase {
     dnnl::memory::dim N = input_shape[0],       // batch size
         IC = input_shape[1],                    // input channels
         IH = input_shape[2],                    // input height
-        IW = input_shape[2],                    // input width
+        IW = input_shape[3],                    // input width
         OC = weight_shape[0],                   // output channels
         KH = weight_shape[2],                   // weight height
         KW = weight_shape[3],                   // weight width
-        PH_L = std::stoi(str_padding[1]),       // height padding: left
-        PH_R = std::stoi(str_padding[3]),       // height padding: right
-        PW_L = std::stoi(str_padding[0]),       // width padding: left
-        PW_R = std::stoi(str_padding[2]),       // width padding: right
+        PW_L = std::stoi(str_padding[1]),       // height padding: left
+        PW_R = std::stoi(str_padding[3]),       // height padding: right
+        PH_L = std::stoi(str_padding[0]),       // width padding: left
+        PH_R = std::stoi(str_padding[2]),       // width padding: right
         SH = std::stoi(str_strides[0]),         // height-wise stride
         SW = std::stoi(str_strides[0]),         // weight-wise stride
         OH = (IH - KH + PH_L + PH_R) / SH + 1,  // output height

